# These substitutions allow the end user to override certain values
substitutions:
  name: "muino-water-meter"

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:

# Enable Over-the-Air firmware updating
ota:
  platform: esphome

# This should point to the public location of this yaml file.
dashboard_import:
  package_import_url: github://martijnvwezel/watermeter-esphome/muino-water-meter-esp32.yaml@main

# Set up a wifi access point using the device name above
wifi:
  ap:

# In combination with the `ap` this allows the user
# to provision wifi credentials to the device.
captive_portal:

esphome:
  name: "${name}"
  # Automatically add the mac address to the name
  # so you can use a single firmware for all devices
  name_add_mac_suffix: true
  platformio_options:
    board_build.flash_mode: "dio"

  # This will allow for (future) project identification,
  # configuration and updates.
  project:
    name: esphome.muino-water-meter
    version: "3.1.0"
  
  # Disable ADC auto update interval
  on_boot:
    priority: 600
    then:
      - output.turn_on: sensor_power
      - component.suspend: sensor_a
      - component.suspend: sensor_b
      - component.suspend: sensor_c

esp32:
  board: seeed_xiao_esp32c3
  framework:
    type: esp-idf

globals:
  - id: phase
    type: int
  - id: liters
    type: int
  - id: dark_a
    type: int
  - id: dark_b
    type: int
  - id: dark_c
    type: int
  - id: light_a
    type: int
  - id: light_b
    type: int
  - id: light_c
    type: int
  - id: diff_a
    type: int
  - id: diff_b
    type: int
  - id: diff_c
    type: int
  - id: max_a
    type: int
  - id: max_b
    type: int
  - id: max_c
    type: int
  - id: min_a
    type: int
  - id: min_b
    type: int
  - id: min_c
    type: int
  - id: upper_bound
    initial_value: "1500"
    type: int
  - id: lower_bound
    type: int
    initial_value: "5"

# triggers reading adc values and iterating algoritm
interval:
  - interval: 100ms
    then:
      - component.update: sensor_a
      - component.update: sensor_b
      - component.update: sensor_c
      - lambda: |-
          id(dark_a) = id(sensor_a).state;
          id(dark_b) = id(sensor_b).state;
          id(dark_c) = id(sensor_c).state;
      - output.turn_on: led
      - delay: 50ms
      - component.update: sensor_a
      - component.update: sensor_b
      - component.update: sensor_c
      - output.turn_off: led
      - lambda: |-
          id(light_a) = id(sensor_a).state;
          id(light_b) = id(sensor_b).state;
          id(light_c) = id(sensor_c).state;
          id(diff_a) = id(light_a) - id(dark_a);
          id(diff_b) = id(light_b) - id(dark_b);
          id(diff_c) = id(light_c) - id(dark_c);
      - component.update: phase_coarse

  # - interval: 1s
  #   then:
  #     # - component.update: report_liters
  #     # - component.update: report_liters_rounded
  #     - logger.log:
  #         level: INFO
  #         tag: time
  #         format: "o:%d"
  #         args: [ 'id(last_water_flow)']
  # #     - logger.log:
  #         level: INFO
  #         tag: max_average
  #         format: "a:%d b:%d c:%d"
  #         args: [ 'id(max_a)', 'id(max_b)' , 'id(max_c)']
  #     - logger.log:
  #         level: INFO
  #         tag: min_average
  #         format: "a:%d b:%d c:%d"
  #         args: [ 'id(min_a)', 'id(min_b)' , 'id(min_c)']

output:
  - platform: gpio
    pin: 7
    id: led
  - platform: gpio
    pin: 6
    id: sensor_power

sensor:
# Analog-digital converters
  - platform: adc
    id: sensor_a
    name: sensor_a
    pin:
      number: 2
      ignore_strapping_warning: true
    raw: true
    internal: true
  - platform: adc
    id: sensor_b
    name: sensor_b
    pin:
      number: 3
    raw: true
    internal: true
  - platform: adc
    id: sensor_c
    name: sensor_c
    pin:
      number: 4
    raw: true
    internal: true

# sensor dark values
  - platform: template
    id: sensor_dark_a
    name: sensor_dark_a
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(dark_a);

  - platform: template
    id: sensor_dark_b
    name: sensor_dark_b
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(dark_b);

  - platform: template
    id: sensor_dark_c
    name: sensor_dark_c
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(dark_c);

# sensor light values
  - platform: template
    id: sensor_light_a
    name: sensor_light_a
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(light_a);

  - platform: template
    id: sensor_light_b
    name: sensor_light_b
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(light_b);

  - platform: template
    id: sensor_light_c
    name: sensor_light_c
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(light_c);

# substracted values
  - platform: template
    id: sensor_diff_a
    name: sensor_diff_a
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(diff_a);

  - platform: template
    id: sensor_diff_b
    name: sensor_diff_b
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(diff_b);

  - platform: template
    id: sensor_diff_c
    name: sensor_diff_c
    force_update: false
    internal: true
    device_class: ILLUMINANCE
    unit_of_measurement: lx
    accuracy_decimals: 0
    lambda: |-
      return id(diff_c);

# liters (public sensor)
  - platform: template
    name: liters
    id: report_liters
    device_class: water
    unit_of_measurement: L
    accuracy_decimals: 0
    state_class: total_increasing
    update_interval: 16s
    lambda: |-
      if (id(liters) < 2) {
        ESP_LOGW("main", "Calibrating, waiting for 2 liters of water consumption...");
        return 0;
      }
      return id(liters);

# phase (1/6 liter resolution)
  - platform: template
    id: phase_coarse
    device_class: water
    state_class: total
    internal: true
    lambda: |-
      static bool first = true;

      int a = id(diff_a);
      int b = id(diff_b);
      int c = id(diff_c);
      int max = id(upper_bound);
      int min = id(lower_bound);

      if (a < min || b < min || c < min ) {
        ESP_LOGW("light_level", "Too dark, a:%d, b:%d, c:%d", a, b, c);
        return 0;
      }

      if (a > max || b > max || c > max) {
        ESP_LOGW("light_level", "Too bright, a:%d, b:%d, c:%d", a, b, c);
        return 0;
      }

      if (first) {
        ESP_LOGI("main", "Initialize phase_coarse");
        id(min_a) = a;
        id(min_b) = b;
        id(min_c) = c;
        id(max_a) = 0;
        id(max_b) = 0;
        id(max_c) = 0;
        first = false;
        return 0;
      }

      float alpha_cor = 0.001;
      if (id(liters) < 2) {
        alpha_cor = 0.1; // when 2 liter not found correct harder
        if (id(liters) < 0) {
          id(liters) = 0;
        }
      }

      auto min_average = [](float x, float y, float alpha_cor) {
        if ((x + 5) <= y && y > 10) {
          return x;
        } else {
          return (1 - alpha_cor) * x + alpha_cor * y;
        }
      };

      auto max_average = [](int x, int y, float alpha_cor) {
        // ESP_LOGI("main", "x: %d, y: %d, a: %f", x, y, alpha_cor);
        if ((x - 5) >= y && y < 2500) {
          return x;
        } else {
          return (int)((1 - alpha_cor) * (float)x + alpha_cor * (float)y);
        }
      };

      id(min_a) = min_average(id(min_a), a, alpha_cor);
      id(min_b) = min_average(id(min_b), b, alpha_cor);
      id(min_c) = min_average(id(min_c), c, alpha_cor);
      id(max_a) = max_average(id(max_a), a, alpha_cor);
      id(max_b) = max_average(id(max_b), b, alpha_cor);
      id(max_c) = max_average(id(max_c), c, alpha_cor);

      a -= (id(min_a) + id(max_a)) >> 1;
      b -= (id(min_b) + id(max_b)) >> 1;
      c -= (id(min_c) + id(max_c)) >> 1;

      short pn[5];

      if (id(phase) & 1) { // odd phase
        pn[0] = a + a - b - c;
        pn[1] = b + b - a - c;
        pn[2] = c + c - a - b; // same
      } else { // even phase
        pn[0] = b + c - a - a; // less
        pn[1] = a + c - b - b; // more
        pn[2] = a + b - c - c; // same
      }

      pn[3] = pn[0];
      pn[4] = pn[1];

      short i = id(phase) > 2 ? id(phase) - 3 : id(phase);

      if (pn[i + 2] < pn[i + 1] && pn[i + 2] < pn[i]) {
        if (pn[i + 1] > pn[i]) {
          id(phase)++;
        } else {
          id(phase)--;
        }
      }

      if (id(phase) == 6) {
        id(liters)++;
        id(phase) = 0;
      } else if (id(phase) == -1) {
        id(liters)--;
        id(phase) = 5;
      }

      return id(liters);
